# External Tape Sort

## Описание проекта

Данный проект представляет собой консольное приложение на C++, реализующее алгоритм внешней сортировки данных, хранящихся на эмулируемом ленточном накопителе. Основная задача — отсортировать последовательность 32-битных целых чисел с входной "ленты" на выходную "ленту" с учетом ограничения на использование оперативной памяти.

Ленточный накопитель (Tape) — это устройство хранения данных с последовательным доступом. Чтение и запись возможны только в текущую позицию головки. Перемещение ленты (сдвиг на одну ячейку или перемотка) является затратной операцией.

## Функционал

1.  **Эмуляция ленточного накопителя (`FileTape`):**
    *   Реализует интерфейс `Tape`.
    *   Использует обычный файл для хранения данных ленты.
    *   Поддерживает операции: чтение (`Read`), запись (`Write`), сдвиг на следующую ячейку (`Next`), сдвиг на предыдущую ячейку (`Prev`), перемотка на заданное смещение (`Rewind`), сброс на начало (`Reset`).
    *   Имеет настраиваемые задержки для каждой операции (чтение, запись, сдвиг, перемотка), которые загружаются из конфигурационного файла.
    *   Управляет использованием оперативной памяти через внутренний буфер, размер которого ограничен.
    *   Позволяет создавать временные ленты (`CreateTemporary`), которые автоматически удаляются при уничтожении объекта `FileTape`. Временные файлы сохраняются в директорию `tmp/`.

2.  **Алгоритмы сортировки:**
    *   **Сортировка подсчетом (`CountingSort`):**
        *   Используется, если в конфигурационном файле указан диапазон значений (`value_range`).
        *   Эффективна для данных с небольшим разбросом значений.
        *   Если весь массив счетчиков не помещается в память, диапазон значений обрабатывается по частям ("окнам").
    *   **По-блочная сортировка слиянием (`ChunkMergeSort`):**
        *   Используется, если диапазон значений не указан.
        *   **Фаза 1 (Сортировка блоков):** Входная лента читается блоками (чанками), размер которых определяется доступной оперативной памятью. Каждый блок сортируется в памяти (используется `std::sort` или `std::heap_sort` в зависимости от флага `strict_stack_limit` в конфиге) и записывается на временные ленты.
        *   **Фаза 2 (Слияние блоков):** Отсортированные чанки попарно сливаются, их размер увеличивается вдвое на каждой итерации. В общем MergeSort.

3.  **Конфигурация:**
    *   Параметры работы приложения (задержки ленты, лимит памяти, опции для алгоритмов сортировки) загружаются из YAML-файла.

4.  **Консольное приложение:**
    *   Принимает на вход три аргумента: путь к входному файлу (ленте), путь к выходному файлу (ленте) и путь к конфигурационному файлу.
    *   Выполняет сортировку и записывает результат в выходной файл.

## Архитектура проекта

*   **`Tape` (include/tape.hpp):** Абстрактный интерфейс, определяющий базовые операции для работы с лентой.
*   **`FileTape` (include/file_tape.hpp, src/file_tape.cpp):** Класс, реализующий интерфейс `Tape` для эмуляции работы с лентой через файловую систему. Управляет буферизацией, задержками и созданием временных файлов.
*   **`VectorTape` (tests/vector_tape.hpp):** Упрощенная реализация `Tape` на основе `std::vector`, используемая исключительно для unit-тестов. Игнорирует задержки и ограничения по памяти.
*   **`Config` (include/config.hpp, src/config.cpp):** Структура для хранения конфигурационных параметров. Включает статический метод `Load` для загрузки настроек из YAML-файла с использованием библиотеки `yaml-cpp`.
*   **`Delays` (include/delays.hpp):** Структура для хранения задержек операций ленты.
*   **Алгоритмы сортировки (в пространстве имен `ext_sort`):**
    *   `CountingSort` (include/external_sort.hpp, src/counting_sort.cpp): Реализация сортировки подсчетом.
    *   `ChunkMergeSort` (include/external_sort.hpp, src/chunk_merge_sort.cpp): Реализация блочной сортировки слиянием.
*   **`FileSort` (include/file_sort.hpp):** Функция-оркестратор, которая инициализирует ленты на основе файлов, загружает конфигурацию и вызывает соответствующий алгоритм сортировки.
*   **`main.cpp` (src/main.cpp):** Точка входа консольного приложения. Обрабатывает аргументы командной строки и вызывает `ext_sort::FileSort`.
*   **`tests/`:** Директория с unit-тестами, использующими фреймворк GoogleTest.

### Структура директорий:

```
.
├── CMakeLists.txt         # Главный CMake-скрипт
├── config/
│   └── settings.yaml      # Пример конфигурационного файла
├── include/               # Заголовочные файлы
│   ├── config.hpp
│   ├── delays.hpp
│   ├── external_sort.hpp
│   ├── file_sort.hpp
│   ├── file_tape.hpp
│   └── tape.hpp
├── src/                   # Файлы с реализацией
│   ├── chunk_merge_sort.cpp
│   ├── config.cpp
│   ├── counting_sort.cpp
│   ├── file_tape.cpp
│   └── main.cpp
├── tests/                 # Unit-тесты
│   ├── CMakeLists.txt
│   ├── helpers.hpp          # Вспомогательные функции для тестов
│   ├── test_chunk_merge_sort.cpp
│   ├── test_config.cpp
│   ├── test_counting_sort.cpp
│   ├── test_file_tape.cpp
│   ├── test_main.cpp        # Тесты для FileSort
│   └── vector_tape.hpp      # Реализация Tape для тестов
└── tmp/                   # Директория для временных файлов лент (создается автоматически)
```

## Зависимости

*   **C++17 компилятор** (например, GCC, Clang, MSVC)
*   **CMake** (версия 3.10 или выше)
*   **yaml-cpp** (библиотека для работы с YAML-файлами)
*   **GoogleTest** (фреймворк для unit-тестирования, загружается CMake, если включена сборка тестов)

## Сборка проекта

1.  **Установка зависимостей:**
    *   Убедитесь, что у вас установлен C++17-совместимый компилятор и CMake.
    *   Установите библиотеку `yaml-cpp`. Способ установки зависит от вашей ОС и пакетного менеджера.

2.  **Сборка:**
    ```bash
    # Клонировать репозиторий (если еще не сделано)
    # git clone <your-repo-url>
    # cd <your-repo-name>

    mkdir build
    cd build
    cmake ..
    cmake --build .
    ```
    Исполняемый файл `tape_sort` (или `tape_sort.exe` на Windows) будет создан в директории `build`.

3.  **Сборка с тестами (включена по умолчанию):**
    Если вы хотите отключить сборку тестов, используйте:
    ```bash
    cmake .. -DBUILD_TESTS=OFF
    ```

## Использование

Для запуска сортировки используйте следующую команду:

```bash
./build/tape_sort <input_file> <output_file> <config_file>
```

Где:
*   `<input_file>`: Путь к бинарному файлу, представляющему входную ленту. Файл должен содержать последовательность 32-битных целых чисел.
*   `<output_file>`: Путь к файлу, куда будет записана отсортированная последовательность (выходная лента). Файл будет создан или перезаписан.
*   `<config_file>`: Путь к YAML-файлу конфигурации (например, `config/settings.yaml`).

**Пример:**
```bash
# Сначала нужно создать входной файл, например, input.bin с какими-то числами
./build/tape_sort input.bin output.bin config/settings.yaml
```
Приложение создаст директорию `tmp/` в текущей рабочей директории для хранения временных файлов лент, если она не существует.

## Конфигурационный файл

Пример конфигурационного файла (`config/settings.yaml`):

```yaml
# Задержки (в миллисекундах)
delays:
  read_ms: 1     # Задержка чтения одного элемента
  write_ms: 1    # Задержка записи одного элемента
  shift_ms: 0    # Задержка сдвига ленты на 1 ячейку
  rewind_ms: 10  # Задержка перемотки ленты на произвольное число ячеек

# Лимит оперативной памяти в байтах
memory_limit_bytes: 104857600  # 100 МБ

# false => std::sort для сортировки чанков в ChunkMergeSort, глубина стека - O(log N)
# true  => heap_sort для сортировки чанков в ChunkMergeSort, глубина стека - O(1)
strict_stack_limit: false

# Дополнительная опция: диапазон значений для Counting Sort
# Если указано, будет использоваться CountingSort с заданным диапазоном.
# Формат: [min_value, max_value]
# Если не указано или массив пуст, используется ChunkMergeSort.
# Пример:
# value_range: [0, 1000]
value_range: []
```

*   **`delays`**: Задержки операций с лентой в миллисекундах.
*   **`memory_limit_bytes`**: Общий лимит оперативной памяти, который приложение может использовать для буферов лент и внутренних нужд алгоритмов.
*   **`strict_stack_limit`**: Если `true`, `ChunkMergeSort` будет использовать `std::heap_sort` для сортировки блоков в памяти (гарантирует O(1) глубину стека). Если `false` (по умолчанию), используется `std::sort` (обычно O(log N) глубина стека).
*   **`value_range`**: Массив из двух целых чисел `[min, max]`. Если этот параметр задан и содержит два значения, приложение будет использовать `CountingSort`. В противном случае будет использован `ChunkMergeSort`.

## Тесты

В проекте реализованы unit-тесты с использованием фреймворка GoogleTest. Тесты покрывают:
*   Работу класса `FileTape` (чтение, запись, перемещение, задержки, управление памятью, временные файлы).
*   Загрузку конфигурации из `Config`.
*   Корректность работы алгоритмов `CountingSort` и `ChunkMergeSort` на различных наборах данных, включая граничные случаи и ограничения по памяти.
*   Работу основного приложения `FileSort` (сквозные тесты).

Для запуска тестов (после успешной сборки проекта с `BUILD_TESTS=ON`):

```bash
cd build
ctest
# или для более подробного вывода в случае ошибок
ctest --output-on-failure
```
Также можно запустить исполняемый файл тестов напрямую:
```bash
./build/tests/unit_tests
```

В тестах для `FileTape` используется перегрузка операторов `new` и `delete` для отслеживания выделения памяти и проверки соблюдения лимитов.
